try:
    import tomllib
except ImportError:
    try:
        import tomli as tomllib
    except ImportError as err:
        msg = "Please install tomli to read TOML files. You can do this by running 'pip install tomli'."
        raise ImportError(msg) from err

from pathlib import Path
from typing import NotRequired, TypeAlias, TypedDict


AUTOGENERATED_WARNING = '// Autogenerated! Do not edit.'

ClassDef = TypedDict(
    'ClassDef',
    {
        'size': int | str,
        'note': NotRequired[str],
        'template-arguments-count': NotRequired[int],
        'template-arguments': NotRequired[list[str]],
    },
)
ClassDefs: TypeAlias = dict[str, ClassDef]


def status(msg: str) -> None:
    print(f'--   {msg}', flush=True)  # noqa: T201


def format_size(size: int | str) -> str:
    if isinstance(size, int):
        return f'0x{size:02x}'
    return size


def cpp_gen_template(template_args: list[str] | None, template_args_count: int | None) -> str | None:
    if template_args is None and template_args_count is None:
        return None

    if template_args_count is not None:
        if template_args:
            msg = 'template-arguments-count and template-arguments cannot be used together'
            raise ValueError(msg)

        template_args = ['typename' for _ in range(template_args_count)]

    args = ', '.join(template_args)
    return f'template <{args}>' if args else ''


def classes_iter(classes: ClassDefs) -> tuple[str, ClassDef]:
    yield from sorted(classes.items(), key=lambda c: c[0])


def assemble_cpp(classes: ClassDefs) -> str:
    result = [
        AUTOGENERATED_WARNING,
        '#pragma once',
        '#include <string_view>',
        '',
    ]

    for name, class_def in classes_iter(classes):
        if template := cpp_gen_template(class_def.get('template-arguments'), class_def.get('template-arguments-count')):
            result.append(template)

        if note := class_def.get('note'):
            result.append(f'// {note}')

        size = format_size(class_def['size'])
        result.append(f'using {name} = char[{size}];')

    result.extend(
        (
            '',
            '// intentionally left undefined. if you want to access static fields, add your own sdk.',
            'namespace interfaces {',
            '    struct SchemaStaticFieldData_t {',
            '        void* m_pInstance{};',
            '    };',
            '',
            '    struct CSchemaClassInfo {',
            '        auto GetStaticFields() -> SchemaStaticFieldData_t**;',
            '    };',
            '',
            '    struct CSchemaSystemTypeScope {',
            '        auto FindDeclaredClass(std::string_view) -> CSchemaClassInfo*;',
            '    };',
            '',
            '    struct schema_t {',
            '        auto FindTypeScopeForModule(std::string_view) -> CSchemaSystemTypeScope*;',
            '    };',
            '',
            '    extern schema_t* g_schema;',
            '} // namespace interfaces',
        )
    )

    return '\n'.join(result) + '\n'


def assemble_c(classes: ClassDefs) -> str:
    result = [
        AUTOGENERATED_WARNING,
        '#pragma once',
        '',
    ]

    for name, class_def in classes_iter(classes):
        if class_def.get('template-arguments') or class_def.get('template-arguments-count'):
            result.append(f'// skipped template {name}')
            continue

        if note := class_def.get('note'):
            result.append(f'// {note}')

        size = format_size(class_def['size'])
        result.append(f'typedef char {name}[{size}];')

    return '\n'.join(result) + '\n'


def dump_to(cwd: Path, language: str, filename: str, content: str) -> None:
    cpp_dir = cwd / 'sdk-static' / language / 'include' / 'source2sdk' / 'source2gen'
    cpp_dir.mkdir(parents=True, exist_ok=True)

    output_file = cpp_dir / filename
    output_file.write_text(content)

    status(f'Wrote {len(content)} bytes to {language}/{filename}')


def main() -> None:
    cwd = Path(__file__).parent.parent.resolve().absolute()
    toml_file: ClassDefs = tomllib.loads((cwd / 'sdk-static.toml').read_text(encoding='utf-8'))

    status(f'Read {len(toml_file)} types from sdk-static.toml')

    cpp = assemble_cpp(toml_file)
    dump_to(cwd, 'cpp', 'source2gen.hpp', cpp)

    c = assemble_c(toml_file)
    dump_to(cwd, 'c', 'source2gen.h', c)


if __name__ == '__main__':
    main()
